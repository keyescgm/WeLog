#NDK技术交流小结
```
JNI是一种在Java虚拟机控制下执行代码的标准机制。代码被编写成汇编程序或者C/C++程序，并组装为动态库。也就允许了非静态绑定用法。
这提供了一个在Java平台上调用C/C++的一种途径，反之亦然。它允许Java类的某些方法原生实现，同时让它们能够像普通Java方法一样被调用和使用。
```
#环境
Java、AndroidStudio、AndroidSDK、NDK、Gradle

#基本使用
1、编写java本地方法
2、生成.h头文件 ， 需要使用到的java命令是javah
3、实现头文件
4、通过ndk-build生成动态链接库
5、配置环境
6、加载动态链接库
7、调用本地方法并执行
---------------------------------------------------------------------------------------------
1、静态注册
   1、编写java本地方法
   public static native String getName();
   2、生成.h头文件 ， 需要使用到的java命令是javah
   javad -d jni -classpath . 类的路径
   生成文件如下
   #include <jni.h>
   /* Header for class com_keyes_jnitest_HelloJni */

   #ifndef _Included_com_keyes_jnitest_HelloJni
   #define _Included_com_keyes_jnitest_HelloJni
   #ifdef __cplusplus
   extern "C" {
   #endif
   /*
    * Class:     com_keyes_jnitest_HelloJni
    * Method:    getName
    * Signature: ()Ljava/lang/String;
    */
   JNIEXPORT jstring JNICALL Java_com_keyes_jnitest_HelloJni_getName
     (JNIEnv *, jclass);

   #ifdef __cplusplus
   }
   #endif
   #endif

   3、实现头文件
    /* DO NOT EDIT THIS FILE - it is machine generated */
    #include <string.h>
    #include <jni.h>
    #include "com_keyes_jnitest_HelloJni.h"
    /* Header for class com_keyes_jnitest_HelloJni */

    /*
     * Class:     com_keyes_jnitest_HelloJni
     * Method:    getName
     * Signature: ()Ljava/lang/String;
     */
    JNIEXPORT jstring JNICALL Java_com_keyes_jnitest_HelloJni_getName
      (JNIEnv * env, jclass thiz)
      {
      #if defined(__arm__)
        #if defined(__ARM_ARCH_7A__)
          #if defined(__ARM_NEON__)
            #if defined(__ARM_PCS_VFP)
              #define ABI "armeabi-v7a/NEON (hard-float)"
            #else
              #define ABI "armeabi-v7a/NEON"
            #endif
          #else
            #if defined(__ARM_PCS_VFP)
              #define ABI "armeabi-v7a (hard-float)"
            #else
              #define ABI "armeabi-v7a"
            #endif
          #endif
        #else
         #define ABI "armeabi"
        #endif
      #elif defined(__i386__)
         #define ABI "x86"
      #elif defined(__x86_64__)
         #define ABI "x86_64"
      #elif defined(__mips64)  /* mips64el-* toolchain defines __mips__ too */
         #define ABI "mips64"
      #elif defined(__mips__)
         #define ABI "mips"
      #elif defined(__aarch64__)
         #define ABI "arm64-v8a"
      #else
         #define ABI "unknown"
      #endif

          return (*env)->NewStringUTF(env, "Hello from JNI !  Compiled with ABI " ABI ".");
      }

   4、通过ndk-build生成动态链接库
   ndk-build

   5、配置环境
   编写Android.mk
   LOCAL_PATH := $(call my-dir)

   include $(CLEAR_VARS)

   LOCAL_MODULE    := HelloJni
   LOCAL_SRC_FILES := dynamic.cpp

   include $(BUILD_SHARED_LIBRARY)

    修改项目的.property文件，添加
    android.useDeprecatedNdk=true

    修改app的build.gradle文件
    sourceSets{
            main{
                jniLibs.srcDirs 'src/main/jniLibs'
            }
        }
   6、加载动态链接库
        static {
           System.loadLibrary("HelloJni");
       }
   7、调用本地方法并执行
      调用getName()执行java文件即可
2、动态注册
```
   步骤和动态注册类似，注意的地方
   添加Application.mk文件
   APP_ABI := all
   APP_STL:=stlport_static

   生成的C文件，需要这样修改
   // jni头文件
   #include <jni.h>

   #include <cassert>
   #include <cstdlib>
   #include <iostream>
   using namespace std;


   //native 方法实现
   jint get_random_num(){
       return rand();
   }
   /*需要注册的函数列表，放在JNINativeMethod 类型的数组中，
   以后如果需要增加函数，只需在这里添加就行了
   参数：
   1.java代码中用native关键字声明的函数名字符串
   2.签名（传进来参数类型和返回值类型的说明）
   3.C/C++中对应函数的函数名（地址）
   */
   static JNINativeMethod getMethods[] = {
           {"getRandomNum","()I",(void*)get_random_num},
   };
   //此函数通过调用JNI中 RegisterNatives 方法来注册我们的函数
   static int registerNativeMethods(JNIEnv* env, const char* className,JNINativeMethod* getMethods,int methodsNum){
       jclass clazz;
       /到声明native方法的类
       clazz = env->FindClass(className);
       if(clazz == NULL){
           return JNI_FALSE;
       }
      //注册函数 参数：java类 所要注册的函数数组 注册函数的个数
       if(env->RegisterNatives(clazz,getMethods,methodsNum) < 0){
           return JNI_FALSE;
       }
       return JNI_TRUE;
   }

   static int registerNatives(JNIEnv* env){
       //指定类的路径，通过FindClass 方法来找到对应的类
       const char* className  = "com/keyes/jnitest/Dynamic";
       return registerNativeMethods(env,className,getMethods, sizeof(getMethods)/ sizeof(getMethods[0]));
   }
   //回调函数 在这里面注册函数
   JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved){
       JNIEnv* env = NULL;
      //判断虚拟机状态是否有问题
       if(vm->GetEnv((void**)&env,JNI_VERSION_1_6)!= JNI_OK){
           return -1;
       }
       assert(env != NULL);
       //开始注册函数 registerNatives -》registerNativeMethods -》env->RegisterNatives
       if(!registerNatives(env)){
           return -1;
       }
       //返回jni 的版本
       return JNI_VERSION_1_6;
   }
```
